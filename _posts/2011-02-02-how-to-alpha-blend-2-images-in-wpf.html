---
layout: post
title: How to Alpha Blend 2 Images in WPF
date: '2011-02-02T00:22:00.000+01:00'
author: Christian Resma Helle
tags:
- Image Manipulation
- WPF
modified_time: '2011-02-02T00:22:46.986+01:00'
blogger_id: tag:blogger.com,1999:blog-4995334164049002857.post-1726784415064280006
blogger_orig_url: https://christian-helle.blogspot.com/2011/02/how-to-alpha-blend-2-images-in-wpf.html
---

After having such fun trying to find optimal ways of manipulating images in WPF I decided to write another short post on image manipulation. This time I'd like to demonstrate how to alpha blend 2 images using the WriteableBitmap class.  <br/><br/>I'm probably not the best one to explain how alpha blending is done but here's the idea in a nutshell. I get the RGB values of every pixel for the each image and write them to a new bitmap where I manipulate each color information by applying the following formula:  <br/><br/>r = ((image1 pixel (red) * alpha level) + (image2 pixel (red) * inverse alpha level)) / 256 <br/>b = ((image1 pixel (blue) * alpha level) + (image2 pixel (blue) * inverse alpha level)) / 256 <br/>g = ((image1 pixel (green) * alpha level) + (image2 pixel (green) * inverse alpha level)) / 256  <br/><br/><div style="font-family: Consolas; font-size: 10pt; color: black; background: white;"><pre style="margin: 0px;"><span style="color: blue;">unsafe</span> <span style="color: blue;">static</span> <span style="color: #2b91af;">WriteableBitmap</span> AlphaBlend(<span style="color: #2b91af;">BitmapSource</span> image1, <span style="color: #2b91af;">BitmapSource</span> image2, <span style="color: blue;">int</span> alphaLevel)</pre><pre style="margin: 0px;">{</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">const</span> <span style="color: blue;">int</span> PIXEL_SIZE = 4;</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">int</span> ialphaLevel = 256 - alphaLevel;</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">int</span> height = <span style="color: #2b91af;">Math</span>.Min(image1.PixelHeight, image2.PixelHeight);</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">int</span> width = <span style="color: #2b91af;">Math</span>.Min(image1.PixelWidth, image2.PixelWidth);</pre><pre style="margin: 0px;">&nbsp;</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> bitmap = <span style="color: blue;">new</span> <span style="color: #2b91af;">WriteableBitmap</span>(width, height, image1.DpiX, image1.DpiY, <span style="color: #2b91af;">PixelFormats</span>.Bgr32, <span style="color: blue;">null</span>);</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> bitmap1 = <span style="color: blue;">new</span> <span style="color: #2b91af;">WriteableBitmap</span>(image1);</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> bitmap2 = <span style="color: blue;">new</span> <span style="color: #2b91af;">WriteableBitmap</span>(image2);</pre><pre style="margin: 0px;">&nbsp;</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; bitmap.Lock();</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; bitmap1.Lock();</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; bitmap2.Lock();</pre><pre style="margin: 0px;">&nbsp;</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> backBuffer = (<span style="color: blue;">byte</span>*)bitmap.BackBuffer.ToPointer();</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> bitmap1Buffer = (<span style="color: blue;">byte</span>*)bitmap1.BackBuffer.ToPointer();</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> bitmap2Buffer = (<span style="color: blue;">byte</span>*)bitmap2.BackBuffer.ToPointer();</pre><pre style="margin: 0px;">&nbsp;</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">for</span> (<span style="color: blue;">int</span> y = 0; y &lt; height; y++)</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> row = backBuffer + (y * bitmap.BackBufferStride);</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> img1Row = bitmap1Buffer + (y * bitmap1.BackBufferStride);</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">var</span> img2Row = bitmap2Buffer + (y * bitmap2.BackBufferStride);</pre><pre style="margin: 0px;">&nbsp;</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">for</span> (<span style="color: blue;">int</span> x = 0; x &lt; width; x++)</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color: blue;">for</span> (<span style="color: blue;">int</span> i = 0; i &lt; PIXEL_SIZE; i++)</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; row[x * PIXEL_SIZE + i] = (<span style="color: blue;">byte</span>)(((img1Row[x * PIXEL_SIZE + i] * alphaLevel) + (img2Row[x * PIXEL_SIZE + i] * ialphaLevel)) &gt;&gt; 8);</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</pre><pre style="margin: 0px;">&nbsp;</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; bitmap.AddDirtyRect(<span style="color: blue;">new</span> Int32Rect(0, 0, width, height));</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; bitmap2.Unlock();</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; bitmap1.Unlock();</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; bitmap.Unlock();</pre><pre style="margin: 0px;">&nbsp;</pre><pre style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">return</span> bitmap;</pre><pre style="margin: 0px;">}</pre></div> <br/><br/>The method above will probably work best if the 2 images are of the same size. I hope you found this information useful.