---
layout: post
title: Working with Native Bitmap pixel buffers in Xamarin.Forms
date: '2016-09-01T00:30:00.000+02:00'
# author: Christian Resma Helle
tags:
- Xamarin
modified_time: '2016-09-02T14:42:24.871+02:00'
blogger_id: tag:blogger.com,1999:blog-4995334164049002857.post-6303647706094978203
blogger_orig_url: https://christian-helle.blogspot.com/2016/09/working-with-native-bitmap-pixel.html
---

I mentioned in my previous post that extracting pixel buffers from native Bitmap APIâ€™s can be quite tricky. In this post I would like to share the approach that I took for extracting native Bitmap pixel buffers into an collection of Xamarin.Forms.Colors objects so it can be used from a portable class library. I wrote and used a more complex version of the code mentioned in this post on my last project where I was working with image detection and color analysis for an app using Xamarin.Forms, in this project all my color analysis was done in a Portable Class Library using an abstraction over the native bitmap data.<br /><br /><strong>BitmapData abstraction</strong><br /><br />In .NET you had access to an API called <a href="http://msdn.microsoft.com/en-us/library/system.drawing.bitmap.aspx" title="System.Drawing.Bitmap" target="_blank" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=http://msdn.microsoft.com/en-us/library/system.drawing.bitmap.aspx&amp;source=gmail&amp;ust=1472906022125000&amp;usg=AFQjCNFdTAWv23M6PLDEmy5WxYn8Tk8gaA">System.Drawing.Bitmap</a> which encapsulates a low-level Windows API called Bitmap from GDI. The managed Bitmap class exposed a method called <a href="https://msdn.microsoft.com/en-us/library/5ey6h79d.aspx" title="LockBits" target="_blank" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=https://msdn.microsoft.com/en-us/library/5ey6h79d.aspx&amp;source=gmail&amp;ust=1472906022125000&amp;usg=AFQjCNEyw2uJprx7N_vlxVCvmjEIHcONSQ">LockBits</a> which in return gave you a <a href="https://msdn.microsoft.com/en-us/library/5ey6h79d.aspx" title="BitmapData" target="_blank" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=https://msdn.microsoft.com/en-us/library/5ey6h79d.aspx&amp;source=gmail&amp;ust=1472906022125000&amp;usg=AFQjCNEyw2uJprx7N_vlxVCvmjEIHcONSQ">BitmapData</a> instance. BitmapData exposed information that allows you to manipulate the pixel buffer at a pointer level and is the fastest and recommended way to analyze and manipulate pixel information. I loved the BitmapData class but my portable class library implementation will not contain anything but a pixel buffer in ARGB and a Get/SetPixel(x,y, Color) method and a method for getting the average color of a certain area in the Bitmap to demonstrate what this can be used for<br /><br />Here's the code<br /><br /><div style="background:#ffffff;border-width:0.1em 0.1em 0.1em 0.8em;border:none;overflow:auto;padding:0.2em 0.6em;width:auto"><pre style="line-height:125%;margin:0"><span style="color:blue">public</span> <span style="color:blue">class</span> <span style="color:#2b91af">BitmapData</span><br />{<br />    <span style="color:blue">public</span> BitmapData(Size size, <span style="color:#2b91af">int</span>[] pixelBuffer)<br />    {<br />        Size = size;<br />        PixelBuffer = pixelBuffer;<br />    }<br /><br />    <span style="color:blue">public</span> <span style="color:#2b91af">int</span>[] PixelBuffer { <span style="color:blue">get</span>; }<br /><br />    <span style="color:blue">public</span> Size Size { <span style="color:blue">get</span>; }<br /><br />    <span style="color:blue">public</span> Color GetPixel(Point point) =&gt; GetPixel(point.X, point.Y);<br /><br />    <span style="color:blue">public</span> Color GetPixel(<span style="color:#2b91af">double</span> x, <span style="color:#2b91af">double</span> y) =&gt; Color.FromUint((<span style="color:#2b91af">uint</span>)<wbr>PixelBuffer[(<span style="color:#2b91af">int</span>)x * (<span style="color:#2b91af">int</span>)y]);<br /><br />    <span style="color:blue">public</span> <span style="color:blue">void</span> SetPixel(Point point, Color color) =&gt; SetPixel((<span style="color:#2b91af">int</span>)point.X, (<span style="color:#2b91af">int</span>)point.Y, color);<br /><br />    <span style="color:blue">public</span> <span style="color:blue">void</span> SetPixel(<span style="color:#2b91af">double</span> x, <span style="color:#2b91af">double</span> y, Color color) =&gt; PixelBuffer[(<span style="color:#2b91af">int</span>)(x * y)] = (<span style="color:#2b91af">int</span>)(color.A * <span style="color:#2b91af">byte</span>.MaxValue) &lt;&lt; 24 |<br />                                                                                        ((<span style="color:#2b91af">int</span>)color.R * <span style="color:#2b91af">byte</span>.MaxValue) &lt;&lt; 16 |<br />                                                                                        ((<span style="color:#2b91af">int</span>)color.G * <span style="color:#2b91af">byte</span>.MaxValue) &lt;&lt; 8 |<br />                                                                                        ((<span style="color:#2b91af">int</span>)color.B * <span style="color:#2b91af">byte</span>.MaxValue) &lt;&lt; 0;<br /><br />    <span style="color:blue">public</span> Color GetAverageColor(<span style="color:blue">params</span> Rectangle[] rectangles)<br />    {<br />        <span style="color:#2b91af">var</span> colors = <span style="color:blue">new</span> List&lt;Color&gt;();<br />        <span style="color:blue">foreach</span> (<span style="color:#2b91af">var</span> rectangle <span style="color:blue">in</span> rectangles)<br />            <span style="color:blue">for</span> (<span style="color:#2b91af">var</span> y = rectangle.Y; y &lt; rectangle.Y + rectangle.Height; y++)<br />                <span style="color:blue">for</span> (<span style="color:#2b91af">var</span> x = (<span style="color:#2b91af">int</span>)rectangle.X; x &lt; (<span style="color:#2b91af">int</span>)rectangle.X + (<span style="color:#2b91af">int</span>)rectangle.Width; x++)<br />                    colors.Add(GetPixel(x, y));<br /><br />        <span style="color:#2b91af">var</span> red = (<span style="color:#2b91af">int</span>)(colors.Average(c =&gt; c.R) * <span style="color:#2b91af">byte</span>.MaxValue);<br />        <span style="color:#2b91af">var</span> blue = (<span style="color:#2b91af">int</span>)(colors.Average(c =&gt; c.G) * <span style="color:#2b91af">byte</span>.MaxValue);<br />        <span style="color:#2b91af">var</span> green = (<span style="color:#2b91af">int</span>)(colors.Average(c =&gt; c.B) * <span style="color:#2b91af">byte</span>.MaxValue);<br />        <span style="color:#2b91af">var</span> alpha = (<span style="color:#2b91af">int</span>)(colors.Average(c =&gt; c.A) * <span style="color:#2b91af">byte</span>.MaxValue);<br />            <br />        <span style="color:blue">return</span> Color.FromRgba(red, blue, green, alpha);<br />    }<br />}<br /></pre></div><br /><strong>UIImage to BitmapData (iOS)</strong><br /><br />To get the pixel buffer from a <a href="https://developer.xamarin.com/api/type/MonoTouch.UIKit.UIImage/" target="_blank" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=https://developer.xamarin.com/api/type/MonoTouch.UIKit.UIImage/&amp;source=gmail&amp;ust=1472906022125000&amp;usg=AFQjCNGrFpwsmNbpo7IM_h-Jt6vEGNEIVQ">UIImage</a> instance we need to draw it to a new drawing surface by calling <a href="https://developer.xamarin.com/api/member/CoreGraphics.CGContext.DrawImage/p/CoreGraphics.CGImage/CoreGraphics.CGRect/" target="_blank" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=https://developer.xamarin.com/api/member/CoreGraphics.CGContext.DrawImage/p/CoreGraphics.CGImage/CoreGraphics.CGRect/&amp;source=gmail&amp;ust=1472906022125000&amp;usg=AFQjCNHJ-sXbKia_LK-Li8IHXZ7SO5kpow">DrawImage</a>&nbsp;on an&nbsp;<a href="https://developer.xamarin.com/api/type/CoreGraphics.CGBitmapContext/" target="_blank" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=https://developer.xamarin.com/api/type/CoreGraphics.CGBitmapContext/&amp;source=gmail&amp;ust=1472906022125000&amp;usg=AFQjCNGjrOomItPXs-bHn3X5gYiz_MBAAQ">CGBitmapContext</a>&nbsp;instance. When we construct the drawing surface we specify the pixel format and provide a pointer or an array of bytes in which the data will be written to. We need to specify that the pixels will contain a byte for each component, 4 bytes per pixel, and that the byte order is 32-bit Big Endian. We can also specify whether we specify the alpha component is in the most or least significant bits of each pixel, but for this example I will put it in the end since when I was researching about this, most of the examples I found used the least significant bit to store the alpha component.<br /><br />Here's the code<br /><br /><div style="background:#ffffff;border-width:0.1em 0.1em 0.1em 0.8em;border:none;overflow:auto;padding:0.2em 0.6em;width:auto"><pre style="line-height:125%;margin:0"><span style="color:blue">public</span> BitmapData Convert(<span style="color:#2b91af">object</span> nativeBitmap)<br />{<br />    <span style="color:#2b91af">var</span> image = (UIImage)nativeBitmap;<br />    <span style="color:blue">return</span> <span style="color:blue">new</span> BitmapData(<span style="color:blue">new</span> Xamarin.Forms.Size(image.Size.<wbr>Width, image.Size.Height), GetPixels(image));<br />}<br /><br /><span style="color:blue">private</span> <span style="color:blue">static</span> <span style="color:#2b91af">int</span>[] GetPixels(UIImage image)<br />{<br />    <span style="color:blue">const</span> <span style="color:#2b91af">int</span> bytesPerPixel = 4;<br />    <span style="color:blue">const</span> <span style="color:#2b91af">int</span> bitsPerComponent = 8;<br />    <span style="color:blue">const</span> CGBitmapFlags flags = CGBitmapFlags.ByteOrder32Big | CGBitmapFlags.<wbr>PremultipliedLast;<br /><br />    <span style="color:#2b91af">var</span> width = (<span style="color:#2b91af">int</span>)image.CGImage.Width;<br />    <span style="color:#2b91af">var</span> height = (<span style="color:#2b91af">int</span>)image.CGImage.Height;<br />    <span style="color:#2b91af">var</span> bytesPerRow = bytesPerPixel * width;<br />    <span style="color:#2b91af">var</span> buffer = <span style="color:blue">new</span> <span style="color:#2b91af">byte</span>[bytesPerRow * height];<br />    <span style="color:#2b91af">var</span> pixels = <span style="color:blue">new</span> <span style="color:#2b91af">int</span>[width * height];<br /><br />    <span style="color:#2b91af">var</span> handle = GCHandle.Alloc(buffer);<br />    <span style="color:blue">try</span><br />    {<br />        <span style="color:blue">using</span> (<span style="color:#2b91af">var</span> colorSpace = CGColorSpace.CreateGenericRgb(<wbr>))<br />        <span style="color:blue">using</span> (<span style="color:#2b91af">var</span> context = <span style="color:blue">new</span> CGBitmapContext(buffer, width, height, bitsPerComponent, bytesPerRow, colorSpace, flags))<br />            context.DrawImage(<span style="color:blue">new</span> RectangleF(0, 0, width, height), image.CGImage);<br /><br />        <span style="color:blue">for</span> (<span style="color:#2b91af">var</span> y = 0; y &lt; height; y++)<br />        {<br />            <span style="color:#2b91af">var</span> offset = y * width;<br />            <span style="color:blue">for</span> (<span style="color:#2b91af">var</span> x = 0; x &lt; width; x++)<br />            {<br />                <span style="color:#2b91af">var</span> idx = bytesPerPixel * (offset + x);<br />                <span style="color:#2b91af">var</span> r = buffer[idx + 0];<br />                <span style="color:#2b91af">var</span> g = buffer[idx + 1];<br />                <span style="color:#2b91af">var</span> b = buffer[idx + 2];<br />                <span style="color:#2b91af">var</span> a = buffer[idx + 3];<br />                pixels[x * y] = a &lt;&lt; 24 | r &lt;&lt; 16 | g &lt;&lt; 8 | b &lt;&lt; 0;<br />            }<br />        }<br />    }<br />    <span style="color:blue">finally</span><br />    {<br />        handle.Free();<br />    }<br /><br />    <span style="color:blue">return</span> pixels;<br />}<br /></pre></div><br /><strong>Bitmap to BitmapData (Android)</strong><br /><br />This is pretty easy to do in Android as the <a href="https://developer.xamarin.com/api/type/Android.Graphics.Bitmap/" target="_blank" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=https://developer.xamarin.com/api/type/Android.Graphics.Bitmap/&amp;source=gmail&amp;ust=1472906022125000&amp;usg=AFQjCNFefaS6uVP7Oj7NxVVMGU2kW4uBaA">Bitmap</a>&nbsp;class exposes the&nbsp;<a href="https://developer.xamarin.com/api/member/Android.Graphics.Bitmap.GetPixels/p/System.Int32%5B%5D/System.Int32/System.Int32/System.Int32/System.Int32/System.Int32/System.Int32/" target="_blank" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=https://developer.xamarin.com/api/member/Android.Graphics.Bitmap.GetPixels/p/System.Int32%255B%255D/System.Int32/System.Int32/System.Int32/System.Int32/System.Int32/System.Int32/&amp;source=gmail&amp;ust=1472906022125000&amp;usg=AFQjCNGQHYvaSTufIWvi3dtiQEiYtmexxQ">GetPixels</a> method to get the pixel buffer and the pixel information is conveniently stored in ARGB<br /><br />Here's the code<br /><br /><div style="background:#ffffff;border-width:0.1em 0.1em 0.1em 0.8em;border:none;overflow:auto;padding:0.2em 0.6em;width:auto"><pre style="line-height:125%;margin:0"><span style="color:blue">public</span> BitmapData Convert(<span style="color:#2b91af">object</span> nativeBitmap)<br />{<br />    <span style="color:#2b91af">var</span> bitmap = (Bitmap)nativeBitmap;<br />    <span style="color:#2b91af">var</span> info = bitmap.GetBitmapInfo();<br />    <span style="color:#2b91af">var</span> pixels = <span style="color:blue">new</span> <span style="color:#2b91af">int</span>[info.Width * info.Height];<br />    bitmap.GetPixels(pixels, 0, (<span style="color:#2b91af">int</span>)info.Width, 0, 0, (<span style="color:#2b91af">int</span>)info.Width, (<span style="color:#2b91af">int</span>)info.Height);<br />    <span style="color:blue">return</span> <span style="color:blue">new</span> BitmapData(<span style="color:blue">new</span> Xamarin.Forms.Size(info.Width, info.Height), pixels);<br />}<br /></pre></div><br /><strong>WriteableBitmap to BitmapData (Universal Windows Platform)</strong><br /><br />To do this using the Universal Windows Platform is a bit similar to iOS but is less complex. The <a href="https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.media.imaging.writeablebitmap.aspx" target="_blank" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.media.imaging.writeablebitmap.aspx&amp;source=gmail&amp;ust=1472906022125000&amp;usg=AFQjCNHzlIhwdKujbkpdPy3972Dp5WHx7w">WriteableBitmap</a>&nbsp;class exposes a <a href="https://msdn.microsoft.com/en-us/library/windows/apps/xaml/windows.ui.xaml.media.imaging.writeablebitmap.pixelbuffer.aspx" target="_blank" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=https://msdn.microsoft.com/en-us/library/windows/apps/xaml/windows.ui.xaml.media.imaging.writeablebitmap.pixelbuffer.aspx&amp;source=gmail&amp;ust=1472906022125000&amp;usg=AFQjCNFGv4F_f86UzCU1jMK-isldk756tg">PixelBuffer </a>as an <a href="https://msdn.microsoft.com/en-us/library/windows/apps/xaml/windows.storage.streams.ibuffer.aspx" target="_blank" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=https://msdn.microsoft.com/en-us/library/windows/apps/xaml/windows.storage.streams.ibuffer.aspx&amp;source=gmail&amp;ust=1472906022126000&amp;usg=AFQjCNFOsDPOQkjuu1EIOKXJ6NO4XfTMVQ">IBuffer </a>in which you can call the extension method ToArray() on to get an array of integers. The interesting part about the WriteableBitmap PixelBuffer is that it doesn't really say anywhere in the documentation (at least not directly) that the component order is BGRA, I only figured this out by reading the sample code provided in the&nbsp;<a href="https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.media.imaging.writeablebitmap.aspx" target="_blank" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.media.imaging.writeablebitmap.aspx&amp;source=gmail&amp;ust=1472906022126000&amp;usg=AFQjCNFBFyioaJ4Wv8NPk3CheFjBR3eKgw">WriteableBitmap</a>&nbsp;<wbr>documentation where it says in a code comment that <b>WriteableBitmap uses BGRA format</b>.<br /><br />Here's the code<br /><br /><div style="background:#ffffff;border-width:0.1em 0.1em 0.1em 0.8em;border:none;overflow:auto;padding:0.2em 0.6em;width:auto"><pre style="line-height:125%;margin:0"><span style="color:blue">public</span> BitmapData Convert(<span style="color:#2b91af">object</span> nativeBitmap)<br />{<br />    <span style="color:#2b91af">var</span> imageSource = (WriteableBitmap)nativeBitmap;<br />    <span style="color:#2b91af">var</span> pixelData = GetPixelDataFromImage(<wbr>imageSource).ToArray();<br />    <span style="color:blue">return</span> <span style="color:blue">new</span> BitmapData(<span style="color:blue">new</span> Size(imageSource.PixelWidth, imageSource.PixelHeight), pixelData);<br />}<br /><br /><span style="color:blue">private</span> <span style="color:blue">static</span> IEnumerable&lt;<span style="color:#2b91af">int</span>&gt; GetPixelDataFromImage(<wbr>WriteableBitmap imageSource)<br />{<br />    <span style="color:blue">const</span> <span style="color:#2b91af">int</span> bytesPerPixel = 4;<br />    <span style="color:#2b91af">var</span> pixelHeight = imageSource.PixelHeight;<br />    <span style="color:#2b91af">var</span> pixelWidth = imageSource.PixelWidth;<br />    <span style="color:#2b91af">var</span> buffer = imageSource.PixelBuffer.<wbr>ToArray();<br />    <span style="color:#2b91af">var</span> pixels = <span style="color:blue">new</span> <span style="color:#2b91af">int</span>[buffer.Length];<br /><br />    <span style="color:blue">for</span> (<span style="color:#2b91af">var</span> y = 0; y &lt; pixelHeight; y++)<br />    {<br />        <span style="color:#2b91af">var</span> offset = y * pixelWidth;<br />        <span style="color:blue">for</span> (<span style="color:#2b91af">var</span> x = 0; x &lt; pixelWidth; x++)<br />        {<br />            <span style="color:#2b91af">var</span> idx = bytesPerPixel * (offset + x);<br />            <span style="color:#2b91af">var</span> b = buffer[idx + 0];<br />            <span style="color:#2b91af">var</span> g = buffer[idx + 1];<br />            <span style="color:#2b91af">var</span> r = buffer[idx + 2];<br />            <span style="color:#2b91af">var</span> a = buffer[idx + 3];<br />            pixels[x * y] = a &lt;&lt; 24 | r &lt;&lt; 16 | g &lt;&lt; 8 | b &lt;&lt; 0;<br />        }<br />    }<br /><br />    <span style="color:blue">return</span> pixels;<br />}<br /></pre></div><br />I remember struggling quite a bit when I was figuring out what I just shared and I hope that some one out there might be able to make some good use of it.<br />