---
layout: post
title: AppCenter Extensions for Xamarin.Forms
date: '2020-02-25T00:51:00.000+01:00'
# author: Christian Resma Helle
tags:
- Xamarin
- AppCenter
modified_time: '2020-03-01T21:32:39.571+01:00'
blogger_id: tag:blogger.com,1999:blog-4995334164049002857.post-320138534571351562
blogger_orig_url: https://christian-helle.blogspot.com/2020/02/appcenter-extensions-for-xamarinforms.html
---

For the past 3 years or so I have been AppCenter for Crash Reporting and Analytics in Xamarin based apps. During this time, I have mostly built enterprise focused apps using Xamarin.Forms and as a developer I always think about code reuse which usually comes in the form of a library. Early this year, I decided to create and open source a set of convenience classes and extension methods to simplify Crash Reporting and Analytics using AppCenter and called it <b><a href="https://github.com/christianhelle/appcenterextensions">AppCenterExtensions</a></b>.<br /><br />The core features of the project are the following:<br /><ul><li>Simplified user interaction reporting using <code>ICommand</code> implementations</li><li>Automatic page tracking in <strong>Xamarin.Forms</strong> including time spent on screen</li><li>Extension methods for crash reporting</li><li>Anonymous user information configuration</li></ul>This library is distributed as 2 NuGet packages<br /><ul><li><a href="https://www.nuget.org/packages/appcenterextensions">AppCenterExtensions</a> - This contains extension methods, <code>ICommand</code> implementations, and convenience classes for initializing and configuring AppCenter. This package depends on <a href="https://www.nuget.org/packages/Microsoft.AppCenter.Analytics/">Microsoft.AppCenter.Analytics</a> and <a href="https://www.nuget.org/packages/Microsoft.AppCenter.Crashes/">Microsoft.AppCenter.Crashes</a> version 2.6.4</li><li><a href="https://www.nuget.org/packages/appcenterextensions.xamarinforms">AppCenterExtensions.XamarinForms</a> - This contains components required for automatic page tracking using <a href="https://github.com/xamarin/Xamarin.Forms">Xamarin.Forms</a>. This package depends on <a href="https://www.nuget.org/packages/appcenterextensions">AppCenterExtensions</a> and <a href="https://www.nuget.org/packages/Xamarin.Forms/">Xamarin.Forms</a> version 4.0.0</li></ul><b>Getting Started</b><br /><br />This library is configured almost the same way as the AppCenter SDK. You provide the AppCenter secrets, and specify whether to anonymize the user information. Both Crash Reporting and Analytics are <strong>always</strong> enabled when using <code>AppCenterSetup</code>.<br /><br /><pre><code>AppCenterSetup.Instance.<span class="hljs-literal">Start</span>(<br />    <span class="hljs-string">"[iOS AppCenter secret]"</span>,<br />    <span class="hljs-string">"[Android AppCenter secret]"</span>,<br />    anonymizeAppCenterUser: <span class="hljs-literal">true</span>);<br /></code></pre>or<br /><pre><code><span class="hljs-keyword">await</span> AppCenterSetup.Instance.StartAsync(<br />    <span class="hljs-string">"[iOS AppCenter secret]"</span>,<br />    <span class="hljs-string">"[Android AppCenter secret]"</span>,<br />    anonymizeAppCenterUser: <span class="hljs-literal">true</span>);<br /></code></pre><br />The reason for the <code>async</code> API here is because <code>anonymizeAppCenterUser</code> internally relies on an <code>async</code> API. The synchronous API's for starting AppCenter are non-blocking methods that do a fire-and-forget call to <code>StartAsync(string,bool)</code>.<br /><b><br /></b> <b>Anonymous User Information</b><br /><b><br /></b> The component <code>AppCenterSetup</code> exposes a method called <code>UseAnonymousUserIdAsync()</code> which sets the UserId in AppCenter to the first 8 characters a GUID that is unique per app installation. This can be used as a <strong>support key</strong> for uniquely identifying application users for instrumentation and troubleshooting. The <strong>support key</strong> can be attached to all HTTP calls by using the <code>DiagnosticDelegatingHandler</code><br /><code><br /></code> <img alt="AppCenter Crash Report" height="640" src="https://github.com/christianhelle/appcenterextensions/blob/master/images/appcenter-crash-report.png?raw=true" width="624" /><br /><b><br /></b> <b>Error Reporting</b><br /><b><br /></b> The library exposes extension methods to the <code>Exception</code> class for conveniently reporting Exceptions to AppCenter<br /><br />Example:<br /><pre><code><span class="hljs-selector-tag">try</span><br />{<br />    <span class="hljs-comment">// Something that blows up</span><br />    <span class="hljs-selector-tag">explosives</span><span class="hljs-selector-class">.Detonate</span>();<br />}<br /><span class="hljs-selector-tag">catch</span> (Exception e)<br />{<br />    <span class="hljs-comment">// Safely handle error then report</span><br />    <span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.Report</span>();<br />}<b><br /></b></code></pre><b><br /></b> <b>HTTP Error Logging</b><br /><b><br /></b> The library provides a <code>HttpMessageHandler</code> implementation that logs non-successfuly HTTP results to AppCenter Analytics. This component will also attach HTTP headers describing the AppCenter SDK Version, Install ID, and a support key to all HTTP requests. The logged failed responses will contain the Endpoint URL (including the HTTP verb), Response status code, how the duration of the HTTP call. This will be logged under the event name <strong>HTTP Error</strong><br /><strong><br /></strong> You will in most (if not all) cases would want to keep a singleton instance of the <code>HttpClient</code>. The <code>DiagnosticDelegatingHandler</code> is designed with unit testing in mind and accepts an <code>IAnalytics</code> and <code>IAppCenterSetup</code> interface, it also accepts an inner <code>HttpMessageHandler</code> if you wish to chain multiple delegating handlers.<br /><br />Example:<br /><pre><code><span class="hljs-keyword">var</span> httpClient = <span class="hljs-keyword">new</span> <span class="hljs-type">HttpClient</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">DiagnosticDelegatingHandler</span>());<br />await httpClient.GetAsync(<span class="hljs-string">"https://entbpr4b9bdpo.x.pipedream.net/"</span>);<br /></code></pre><br />In the example above we made an HTTP GET call to the <a href="https://requestbin.com/">RequestBin</a> endpoint <a href="https://entbpr4b9bdpo.x.pipedream.net/">https://entbpr4b9bdpo.x.pipedream.net</a>. This will result in the following we inspected in <a href="https://requestbin.com/r/entbpr4b9bdpo/1XO0uroL0xZlDfvPNKlFBZaRLo0">RequestBin</a><br /><br /><img alt="AppCenter Crash Report" height="193" src="https://github.com/christianhelle/appcenterextensions/blob/master/images/http-diagnostic-headers.png?raw=true" width="640" /><br /><b><br /></b> <b>ITrackingCommand</b><br /><b><br /></b> This library provides 3 convenience implementations of <code>ICommand</code> that will report the action to AppCenter Analytics after successfully invoking the execute callback method<br /><ul><li><strong><em>TrackingCommand</em></strong> - This implementation accepts an <code>Action</code> as the Execute callback and a <code>Func&lt;bool&gt;</code> as the CanExecute callback</li><li><strong><em>TrackingCommand<t></t></em></strong> - This implementation accepts an <code>Action&lt;T&gt;</code> as the Execute callback and a <code>Func&lt;T, bool&gt;</code> as the CanExecute callback</li><li><strong><em>AsyncTrackingCommand</em></strong> - This implementation accepts a <code>Func&lt;Task&gt;</code> as the execute callback and a <code>Func&lt;bool&gt;</code> as the CanExecute callback. This also exposes a <code>CompletionTask</code> property that the consumer can <code>await</code> if desired. The <code>Execute(object parameter)</code> method here is a non-blocking call</li></ul>Example:<br /><pre><code><span class="hljs-keyword">using</span> System.Threading.Tasks;<br /><span class="hljs-keyword">using</span> System.Windows.Input;<br /><span class="hljs-keyword">using</span> ChristianHelle.DeveloperTools.AppCenterExtensions.Commands;<br /><span class="hljs-keyword">using</span> ChristianHelle.DeveloperTools.AppCenterExtensions.Extensions;<br /><span class="hljs-keyword">using</span> Microsoft.AppCenter.Crashes;<br /><span class="hljs-keyword">using</span> Xamarin.Essentials;<br /><br /><span class="hljs-keyword">namespace</span> <span class="hljs-title">SampleApp.ViewModels</span><br />{<br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AboutViewModel</span> : <span class="hljs-title">BaseViewModel</span><br />    {<br />        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AboutViewModel</span>(<span class="hljs-params"></span>)<br />        </span>{<br />            AsyncButtonTappedCommand = <span class="hljs-keyword">new</span> AsyncTrackingCommand(<br />                OnAsyncButtonTapped,<br />                <span class="hljs-keyword">nameof</span>(AsyncButtonTappedCommand).ToTrackingEventName(),<br />                <span class="hljs-keyword">nameof</span>(AboutViewModel).ToTrackingEventName());<br /><br />            ButtonOneTappedCommand = <span class="hljs-keyword">new</span> TrackingCommand(<br />                OnButtonOneTapped,<br />                <span class="hljs-keyword">nameof</span>(ButtonOneTappedCommand).ToTrackingEventName(),<br />                <span class="hljs-keyword">nameof</span>(AboutViewModel).ToTrackingEventName());<br /><br />            ButtonTwoTappedCommand = <span class="hljs-keyword">new</span> TrackingCommand&lt;<span class="hljs-keyword">string</span>&gt;(<br />                OnButtonTapped,<br />                <span class="hljs-keyword">nameof</span>(ButtonTwoTappedCommand).ToTrackingEventName(),<br />                <span class="hljs-keyword">nameof</span>(AboutViewModel).ToTrackingEventName());<br />        }<br /><br />        <span class="hljs-keyword">public</span> ICommand AsyncButtonTappedCommand { <span class="hljs-keyword">get</span>; }<br />        <span class="hljs-keyword">public</span> ICommand ButtonOneTappedCommand { <span class="hljs-keyword">get</span>; }<br />        <span class="hljs-keyword">public</span> ICommand ButtonTwoTappedCommand { <span class="hljs-keyword">get</span>; }<br /><br />        <span class="hljs-function"><span class="hljs-keyword">private</span> Task <span class="hljs-title">OnAsyncButtonTapped</span>(<span class="hljs-params"></span>)<br />            </span>=&gt; Browser.OpenAsync(<span class="hljs-string">"https://xamarin.com"</span>);<br /><br />        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnButtonOneTapped</span>(<span class="hljs-params"></span>) </span>{ }<br /><br />        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnButtonTwoTapped</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> obj</span>) </span>{ }<br />    }<br />}<br /></code></pre><br />Specifying the <code>screenName</code> argument in the constructor is optional and when this is not provided manually then it will use the declaring <code>Type</code> name from the method that instantiated the <code>ITrackingCommand</code> instance and convert it to a more analytics friendly event name using the <code>ToTrackingEventName()</code> extension method. In the example above, if the <code>nameof(AboutViewModel).ToTrackingEventName()</code> parameter is not provided then the owner declaring Type is <code>AboutViewModel</code> and the <code>ScreenName</code> will be set to <code>"About"</code><br /><b><br /></b> <b>Automatic Page Tracking</b><br /><b><br /></b> Automatic page tracking is enabled by replacing the base class of the <code>ContentPage</code> to classes to use <code>TrackingContentPage</code> class. By doing so the library will send page tracking information to AppCenter after leaving every page. Currently, the library will send the page Type, Title, and the duration spent on the screen. The library is rather opinionated on how to log information, and this will only change if I get a request to do so. Duration spent on screen is calculated using a <code>Stopwatch</code> that is started upon Page <code>OnAppearing</code> and is reported to Analytics upon <code>OnDisappearing</code>. The event name is based on the <code>Type</code> name of the <code>Page</code> and is split into multiple words based on pascal case rules and afterwards removes words like <code>Page</code>, <code>View</code>, <code>Model</code>, <code>Async</code>. For example: <code>UserSettingsPage</code> or <code>UserSettingsView</code> becomes <strong>User Settings</strong><br /><strong><br /></strong> XAML Example:<br /><pre><code>&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;<br />&lt;ext:TrackingContentPage <br />    xmlns=<span class="hljs-string">"http://xamarin.com/schemas/2014/forms"</span> <br />    xmlns:x=<span class="hljs-string">"http://schemas.microsoft.com/winfx/2009/xaml"</span> <br />    xmlns:d=<span class="hljs-string">"http://xamarin.com/schemas/2014/forms/design"</span> <br />    xmlns:mc=<span class="hljs-string">"http://schemas.openxmlformats.org/markup-compatibility/2006"</span><br />    xmlns:ext=<span class="hljs-string">"clr-namespace:AppCenterExtensions.XamarinForms;assembly=AppCenterExtensions.XamarinForms"</span><br />    mc:Ignorable=<span class="hljs-string">"d"</span> <br />    x:Class=<span class="hljs-string">"SampleApp.Views.ItemDetailPage"</span> <br />    Title=<span class="hljs-string">"{Binding Title}"</span>&gt;<br /><br />    &lt;StackLayout Spacing=<span class="hljs-string">"20"</span> <span class="hljs-keyword">Padding</span>=<span class="hljs-string">"15"</span>&gt;<br />        &lt;<span class="hljs-keyword">Label</span> <span class="hljs-keyword">Text</span>=<span class="hljs-string">"Text:"</span> <span class="hljs-keyword">FontSize</span>=<span class="hljs-string">"Medium"</span> /&gt;<br />        &lt;<span class="hljs-keyword">Label</span> <span class="hljs-keyword">Text</span>=<span class="hljs-string">"{Binding Item.Text}"</span> d:<span class="hljs-keyword">Text</span>=<span class="hljs-string">"Item name"</span> <span class="hljs-keyword">FontSize</span>=<span class="hljs-string">"Small"</span> /&gt;<br />        &lt;<span class="hljs-keyword">Label</span> <span class="hljs-keyword">Text</span>=<span class="hljs-string">"Description:"</span> <span class="hljs-keyword">FontSize</span>=<span class="hljs-string">"Medium"</span> /&gt;<br />        &lt;<span class="hljs-keyword">Label</span> <span class="hljs-keyword">Text</span>=<span class="hljs-string">"{Binding Item.Description}"</span> d:<span class="hljs-keyword">Text</span>=<span class="hljs-string">"Item description"</span> <span class="hljs-keyword">FontSize</span>=<span class="hljs-string">"Small"</span> /&gt;<br />    &lt;/StackLayout&gt;<br /><br />&lt;/ext:TrackingContentPage&gt;<b><br /></b></code></pre><b><br /></b> <b>Custom Trace Listener</b><br /><b><br /></b> This library includes a trace listener implementation that reports to AppCenter. The reason for this is to cater to those who have implemented error handling or reporting using Trace Listeners, these types of users can just swap out (or add on) the <code>AppCenterTraceListener</code><br /><code><br /></code> This implementation implements the following methods:<br /><ul><li><code>Write(object obj)</code></li><li><code>Write(object obj, string category)</code></li><li><code>WriteLine(object obj)</code></li><li><code>WriteLine(object obj, string category)</code></li></ul>If the <code>object</code> provided is an <code>Exception</code> then this is reported to AppCenter Crash Reporting. If the <code>object</code> provided is an instance of <code>AnalyticsEvent</code> then this is sent to AppCenter Analytics<br /><br />The <code>AnalyticsEvent</code> exposes 2 properties:<br /><ul><li><code>string EventName { get; }</code> - self explanatory</li><li><code>IDictionary&lt;string,string&gt; Properties { get; }</code> - Additional properties to attach to the Analytics event</li></ul>To set it up you simply add an instance of <code>AppCenterTraceListener</code> to your existing Trace listeners:<br /><pre><code><span class="hljs-selector-tag">Trace</span><span class="hljs-selector-class">.Listeners</span><span class="hljs-selector-class">.Add</span>(<span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">AppCenterTraceListener</span>());<br /></code></pre><br />Here's an example of how to use <code>System.Diagnostics.Trace</code> to report errors<br /><pre><code><span class="hljs-keyword">try</span><br />{<br />    <span class="hljs-comment">// Something that blows up</span><br />    explosives.Detonate();<br />}<br /><span class="hljs-keyword">catch</span> (Exception e)<br />{<br />    <span class="hljs-comment">// Safely handle error then report</span><br />    Trace.<span class="hljs-keyword">Write</span>(e);<br /><br />    <span class="hljs-comment">// or</span><br />    Trace.<span class="hljs-keyword">Write</span>(e, <span class="hljs-string">"Error"</span>);<br /><br />    <span class="hljs-comment">// or</span><br />    Trace.<span class="hljs-keyword">WriteLine</span>(e);<br /><br />    <span class="hljs-comment">// or</span><br />    Trace.<span class="hljs-keyword">WriteLine</span>(e, <span class="hljs-string">"Error"</span>);<br />}<br /></code></pre>and here's an example of to use <code>System.Diagnostics.Trace</code> to send analytics data<br /><pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">App</span> : <span class="hljs-title">Application</span><br />{<br />    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> StateKey = <span class="hljs-string">"State"</span>;<br /><br />    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)<br />    </span>{<br />        <span class="hljs-comment">// Some initialization code ...</span><br /><br />        Trace.Listeners.Add(<span class="hljs-keyword">new</span> AppCenterTraceListener());<br />    }<br /><br />    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStart</span>(<span class="hljs-params"></span>)<br />        </span>=&gt; Trace.Write(<br />            <span class="hljs-keyword">new</span> AnalyticsEvent(<br />                <span class="hljs-keyword">nameof</span>(Application),<br />                <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">string</span>&gt;<br />                {<br />                    { StateKey, <span class="hljs-keyword">nameof</span>(OnStart) }<br />                }));<br /><br />    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSleep</span>(<span class="hljs-params"></span>)<br />        </span>=&gt; Trace.Write(<br />            <span class="hljs-keyword">new</span> AnalyticsEvent(<br />                <span class="hljs-keyword">nameof</span>(Application),<br />                <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">string</span>&gt;<br />                {<br />                    { StateKey, <span class="hljs-keyword">nameof</span>(OnSleep) }<br />                }));<br /><br />    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnResume</span>(<span class="hljs-params"></span>)<br />        </span>=&gt; Trace.Write(<br />            <span class="hljs-keyword">new</span> AnalyticsEvent(<br />                <span class="hljs-keyword">nameof</span>(Application),<br />                <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">string</span>&gt;<br />                {<br />                    { StateKey, <span class="hljs-keyword">nameof</span>(OnResume) }<br />                }));<br />}<b><br /></b></code></pre><b><br /></b> <b>Task Extensions</b><br /><b><br /></b> This library includes a few Task extension methods with AppCenter error reporting in mind. Possible exceptions that occur in the async operation are swallowed and reported to AppCenter. These extension methods will internally wrap the Task in a <code>try/catch</code> and <code>await</code> the Task using <code>ConfigureAwait(false)</code>. <br /><br />Here are usage some examples<br /><br /><div style="display: inline !important;">Fire and Forget on a <code>Task</code> (Note: <code>Forget()</code> returns <code>void</code>)</div><div><pre><span class="hljs-keyword">var</span> <span class="hljs-keyword">task</span> = someClass<span class="hljs-variable">.SomethingAsync</span>()<br /><span class="hljs-keyword">task</span><span class="hljs-variable">.Forget</span>()</pre><div style="display: inline !important;"></div><div><div style="display: inline !important;"><br /></div></div>Awaitable <code>Task</code> (also available for <code>Task&lt;T&gt;</code>)<br /><div><pre><span class="hljs-keyword">var</span> <span class="hljs-keyword">task</span> = someClass<span class="hljs-variable">.SomethingAsync</span>()<br />await <span class="hljs-keyword">task</span><span class="hljs-variable">.WhenErrorReportAsync</span>();</pre><pre></pre></div></div>