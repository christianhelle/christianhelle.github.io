---
layout: post
title: Generate Refit interface from OpenAPI specifications on build time with MSBuild
date: '2024-12-12'
author: Christian Helle
tags: 
- REST
- OpenAPI
redirect_from:
- /2024/12/generate-refit-msbuild/
- /2024/12/generate-refit-msbuild
- /2024/generate-refit-msbuild/
- /2024/generate-refit-msbuild
- /generate-refit-msbuild/
- /generate-refit-msbuild
---

I have tried multiple approaches to using Refitter to generate Refit interfaces and contracts from OpenAPI specifications at build time. My initial approach was to use Rosyln Source Generators to update the generated code. However, I found that using MSBuild was a more straightforward approach. This was because Source Generators run independently of each other, which means that the Refit Source Generators will pickup the code generated by Refitter at compile time, resulting in an experience that requires to build the project twice.

To use Refitter from MSBuild you can do something like this in your `.csproj` file

```xml
<Target Name="Refitter" AfterTargets="PreBuildEvent">
    <Exec WorkingDirectory="$(ProjectDir)" Command="refitter --settings-file .refitter --skip-validation" />
</Target>
```

What happens in the code above is that the Refitter will run before the build process starts, generating the Refit interfaces and contracts from the OpenAPI specification specified in the `.refitter` file.

The code above also assumes that you already have Refitter installed as a global .NET Tool and that the project folder contains a file called `.refitter`. This might not be the case if you're running on a build agent from a CI/CD environment. In this case you might want to install Refitter as a local tool using a manifest file, as described in [this tutorial](https://learn.microsoft.com/en-us/dotnet/core/tools/local-tools-how-to-use?WT.mc_id=DT-MVP-5004822)

```xml
<Target Name="Refitter" AfterTargets="PreBuildEvent">
    <Exec WorkingDirectory="$(ProjectDir)" Command="dotnet tool restore" />
    <Exec WorkingDirectory="$(ProjectDir)" Command="refitter --settings-file .refitter --skip-validation" />
</Target>
```

The `dotnet build` process does will probably not have access to the package repository in which to download Refitter from, this is at least the case with Azure Pipelines and Azure Artifacts. To workaround this, you can provide a separate `nuget.config` that only uses `nuget.org` as a `<packageSource>`.

Something like this:

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <clear />
    <add key="NuGet" value="https://api.nuget.org/v3/index.json" />
  </packageSources>
</configuration>
```

You might want to place the `nuget.config` file in another folder to avoid using it to build the .NET project, then you can specify this when executing `dotnet tool restore`

```xml
<Target Name="Refitter" AfterTargets="PreBuildEvent">
    <Exec WorkingDirectory="$(ProjectDir)" Command="dotnet tool restore --configfile refitter/nuget.config" />
    <Exec WorkingDirectory="$(ProjectDir)" Command="refitter --settings-file .refitter --skip-validation" />
</Target>
```

In the example above, the `nuget.config` file is placed under the `refitter` folder.
