---
layout: post
title: Generate Refit interfaces from OpenAPI specifications on build time with MSBuild
date: '2024-11-01'
author: Christian Helle
tags: 
- REST
- OpenAPI
redirect_from:
- /2024/11/generate-refit-msbuild/
- /2024/11/generate-refit-msbuild
- /2024/generate-refit-msbuild/
- /2024/generate-refit-msbuild
- /generate-refit-msbuild/
- /generate-refit-msbuild
---

Around 2 years ago, I created a tool called [Refitter](https://github.com/christianhelle/refitter) that can generate Refit interfaces and contracts from OpenAPI specifications. I have used Refitter in multiple projects and found it to be a valuable tool when working with REST APIs and primarilly use it as part of the build process. 

I have tried multiple approaches to using [Refitter](https://github.com/christianhelle/refitter) to generate Refit interfaces and contracts from OpenAPI specifications at build time. My initial approach was to use Rosyln Source Generators to update the generated code. However, I found that using MSBuild was a more straightforward approach. This was because Source Generators run independently of each other, which means that the Refit Source Generators will not pickup the code generated by [Refitter](https://github.com/christianhelle/refitter) at compile time, resulting in an experience that requires to build the project twice.

To use [Refitter](https://github.com/christianhelle/refitter) from MSBuild you can do something like this in your `.csproj` file

```xml
<Target Name="Refitter" AfterTargets="PreBuildEvent">
  <Exec WorkingDirectory="$(ProjectDir)" Command="refitter --settings-file .refitter --skip-validation" />
</Target>
```

What happens in the code above is that the [Refitter](https://github.com/christianhelle/refitter) will run before the build process starts, generating the Refit interfaces and contracts from the OpenAPI specification specified in the `.refitter` file.

The code above also assumes that you already have Refitter installed as a global .NET Tool and that the project folder contains a file called `.refitter`. This might not be the case if you're running on a build agent from a CI/CD environment. In this case you might want to install Refitter as a local tool using a manifest file, as described in [this tutorial](https://learn.microsoft.com/en-us/dotnet/core/tools/local-tools-how-to-use?WT.mc_id=DT-MVP-5004822)

Installing [Refitter](https://github.com/christianhelle/refitter) as a local .NET tool would produce a `dotnet-tools.json` file in the `.config` folder, which you can use to restore the tool before running [Refitter](https://github.com/christianhelle/refitter). This can be done by adding a `dotnet tool restore` command before running Refitter.

An example of a .NET tool manifest file would be something like this:

```json
{
  "version": 1,
  "isRoot": true,
  "tools": {
    "refitter": {
      "version": "1.4.0",
      "commands": [
        "refitter"
      ]
    }
  }
}
```

To use the `dotnet tool restore` command you can modify the MSBuild target to look like this:

```xml
<Target Name="Refitter" AfterTargets="PreBuildEvent">
  <Exec WorkingDirectory="$(ProjectDir)" Command="dotnet tool restore" />
  <Exec WorkingDirectory="$(ProjectDir)" Command="refitter --settings-file .refitter --skip-validation" />
</Target>
```

The `dotnet build` process does will probably not have access to the package repository in which to download [Refitter](https://github.com/christianhelle/refitter) from, this is at least the case with Azure Pipelines and Azure Artifacts. To workaround this, you can provide a separate `nuget.config` that only uses `nuget.org` as a `<packageSource>`.

Something like this:

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <clear />
    <add key="NuGet" value="https://api.nuget.org/v3/index.json" />
  </packageSources>
</configuration>
```

You might want to place the `nuget.config` file in another folder to avoid using it to build the .NET project, then you can specify this when executing `dotnet tool restore`

```xml
<Target Name="Refitter" AfterTargets="PreBuildEvent">
  <Exec WorkingDirectory="$(ProjectDir)" Command="dotnet tool restore --configfile refitter/nuget.config" />
  <Exec WorkingDirectory="$(ProjectDir)" Command="refitter --settings-file .refitter --skip-validation" />
</Target>
```

In the example above, the `nuget.config` file is placed under the `refitter` folder.

Files that are generated during the `PreBuildEvent`` are not automatically included in the project. To include the generated files, you can add them to the project file using the `ItemGroup` element. You can either specify the files directly or use a wild card to include all files with a specific extension, or files in a specific folder, or you can explicitly specify the files that should be included.

```xml
<Target Name="Refitter" AfterTargets="PreBuildEvent">
  <Exec WorkingDirectory="$(ProjectDir)" Command="dotnet tool restore --configfile refitter/nuget.config" />
  <Exec WorkingDirectory="$(ProjectDir)" Command="refitter --settings-file .refitter --skip-validation" />
  <ItemGroup>
    <Compile Include="**\*.Generated.cs" />
  </ItemGroup>
</Target>
```

In the example above, I know that [Refitter](https://github.com/christianhelle/refitter) will output files ending in `.Generated.cs`, so I'm including all files with that extension. An issue with including generated files like this is that the compiler will complain if the file already exists, a way around this would be to use the `Condition` parameter and only include the file if it doesn't already exist. Something like this:

```xml
<Target Name="Refitter" AfterTargets="PreBuildEvent">
  <Exec WorkingDirectory="$(ProjectDir)" Command="dotnet tool restore --configfile refitter/nuget.config" />
  <Exec WorkingDirectory="$(ProjectDir)" Command="refitter --settings-file .refitter --skip-validation" />
  <ItemGroup>
    <Compile Include="Petstore.cs" Condition="!Exists('Petstore.cs')" />
  </ItemGroup>
</Target>
```

